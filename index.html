// --- Setup Three.js Scene ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Particle System ---
const particleCount = 8008; // Your requested number
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const colors = new Float32Array(particleCount * 3);

for (let i = 0; i < particleCount * 3; i++) {
    positions[i] = (Math.random() - 0.5) * 10;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true });
const points = new THREE.Points(geometry, material);
scene.add(points);

// --- Hand Tracking Logic (MediaPipe) ---
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });

hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const hand = results.multiHandLandmarks[0];
        
        // Example: Track Index Finger Tip (Landmark 8)
        const x = (hand[8].x - 0.5) * 20;
        const y = -(hand[8].y - 0.5) * 20;

        updateParticleBehavior(x, y, hand);
    }
});

// --- Dynamic Behavior ---
function updateParticleBehavior(hx, hy, landmarks) {
    const pos = geometry.attributes.position.array;
    
    // Check for "Pinch" gesture to trigger expansion
    const distance = Math.sqrt(
        Math.pow(landmarks[4].x - landmarks[8].x, 2) + 
        Math.pow(landmarks[4].y - landmarks[8].y, 2)
    );

    for (let i = 0; i < particleCount; i++) {
        const idx = i * 3;
        // Logic to move positions[idx] towards target shapes
        // If distance < 0.05 (Pinch), explode particles
        if (distance < 0.05) {
            pos[idx] *= 1.05; // Expansion
        }
    }
    geometry.attributes.position.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

